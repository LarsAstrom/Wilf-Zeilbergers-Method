In the thesis computer algebra is investigated and a library for manipulating and working with polynomials is produced. Then this package is used to implement Wilf-Zeilberger's method, which is a method to prove identities involving (infinite) summation. Although there already are toolboxes available in several different software languages that handles polynomials we will develope a new system, in order to experience implementation pitfalls and difficulties first hand.

Computer algebra has been developed during the second half of the \nth{20} century. Martinus Veltman won the Nobel prize in physics 1999 due to his work with developing a computer algebraic software for particle physics. The first working version dates back to the 1960s. \reference{veltman} This was one example of an early computer algebraic system.

Computer algebraic systems are used to automize manipulation of mathematical expressions that are similar to traditional pen and paper calculations. The advantage of computer algebra is that the power of a computer is used, meaning that computations can be performed extremely fast and with improved computational power the possibilities are neverending. This is the reason computer algebra is growing as a field, and why it is both important and interesting to investigate.

Before starting this thesis I did not know much about computer algebra. Although it is a big part of almost all tools that have been used during courses in my program at LTH (such as MATLAB and Maple), I have never given the details of how implementation is done much thought. Therefore this thesis has given me the opportunity to investigate the basics of computer algebra, while providing an open source implementation of Wilf-Zeilberger's method.

The goal of the thesis is to, by implementing a library for polynomial computer algebra, implement an automatic solver which can prove identities using Wilf-Zeilberger's method. Furthermore the goal is to get a deeper understanding of implementation difficulties in computer algebra by implementing everything, and the implementation should rather be simple and easy to understand than complicated but more efficient computationally.
